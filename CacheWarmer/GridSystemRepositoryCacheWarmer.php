<?php
namespace ERD\GridSystemBundle\CacheWarmer;

use Symfony\Component\HttpKernel\CacheWarmer\CacheWarmerInterface;
use Symfony\Component\HttpKernel\CacheWarmer\CacheWarmer;
use ERD\GridSystemBundle\Model\GridSystemRepository;
use ERD\GridSystemBundle\Controller\GridControllerInterface;
/**
 * Description of GridSystemRepositoryCacheWarmer
 *
 * @author Ethan Resnick Design <hi@ethanresnick.com>
 * @copyright Jun 8, 2012 Ethan Resnick Design
 */
class GridSystemRepositoryCacheWarmer extends CacheWarmer implements CacheWarmerInterface
{
    protected $repo;
    
    protected $controller;

    /**
     * @param GridSystemRepository $repo The repository of grid systems whose cache files should be generated.
     * @param GridControllerInterface $controller A controller implementing GridControllerInterface
     */
    public function __construct(GridSystemRepository $repo, GridControllerInterface $controller)
    {
        $this->repo = $repo;
        $this->controller = $controller;
    }

    public function isOptional()
    {
        //Unlike, for example, a twig template, which will be warm itself as needed (i.e.
        //automatically regenerate after cache:clear in response to a request), this bunlde 
        //doesn't respond to requests; it just dumps files to the file system independently. So 
        //those files need to always be there for the bundle to work, so warming isn't optional.
        return false; 
    }
    
    /**
     * Warms up the cache.
     *
     * @param string $cacheDir The cache directory
     */
    public function warmUp($cacheDir)
    {
        $this->clearOldFiles($cacheDir);
   
        $systems = $this->repo->getGridSystems();
        
        //keep track of all the files output so we can make sure we delete them all on
        //cache clear, even if the configurations creating those files have been changed
        //since last warmup.
        $outputs = array();
        
        //output each file
        foreach($systems as $system)
        {
            $conf     = $this->repo->getGridSystemConfig($system);
            $template = $conf[GridSystemRepository::CONFIG_TEMPLATE_KEY];
            $output   = $conf[GridSystemRepository::CONFIG_OUTPUT_KEY];
 
            $result = $this->controller->generate($system, $template);

            $prefix = <<<EOD
/*************************************************************************** 
 DO NOT EDIT THIS FILE DIRECTLY. ANY CHANGES MADE HERE WILL BE OVERWRITTEN
 WHEN THE FILE IS NEXT REGENERATED AUTOMATICALLY (USUALLY WHEN YOU CLEAR
 YOUR CACHE) BY ERDGridSystemBundle. INSTEAD, EDIT THE TEMPLATE ($template)
 OR CONFIGURATION FILE RESPONSIBLE FOR GENERATING THIS FILE INSTEAD.
**************************************************************************/\n\n
EOD;
        
            //Output file to user specified location
            $this->writeCacheFile($output, $prefix.$result);
            
            $outputs[] = $output; //add the file to our list of output files
        }
        
        //add our list of output files to a file in the main cache dir
        $this->writeCacheFile($cacheDir.'/bundles/erd/gridsystembundle/last_outputs.txt', var_export($outputs, true));
    }
    
    /**
     * @todo Move this to a cache_clearer service on updating to Symfony 2.1
     * @see  https://github.com/symfony/symfony/issues/1884
     */
    public function clearOldFiles($cacheDir)
    {
        $file     = $cacheDir.'/bundles/erd/gridsystembundle/last_outputs.txt';
        $contents = @file_get_contents($file);
        
        if($contents)
        {
            eval('$cachedFiles = '.$contents.';');
            
            foreach($cachedFiles as $file)
            {
                @unlink($file);
            }
        }
    }
    
    protected function writeCacheFile($path, $content)
    {
        //try to make the directory before writing
        $parts = explode('/', $path);
        array_pop($parts);
        $dir = '';
        foreach($parts as $part)
        {
            if(!is_dir($dir .= "/$part")) mkdir($dir);
        }
        
        parent::writeCacheFile($path, $content);
    }
}